package com.uib.web.peptideshaker.presenter.core.filtercharts.updatedfilters;

import com.ejt.vaadin.sizereporter.ComponentResizeEvent;
import com.ejt.vaadin.sizereporter.SizeReporter;
import com.google.common.collect.Sets;
import com.itextpdf.text.pdf.codec.Base64;

import com.uib.web.peptideshaker.model.core.AlphanumComparator;
import com.uib.web.peptideshaker.model.core.ModificationMatrix;
import com.uib.web.peptideshaker.presenter.components.peptideshakerview.components.SelectionManager;
import com.uib.web.peptideshaker.presenter.core.filtercharts.charts.RegistrableFilter;
import com.uib.web.peptideshaker.presenter.core.filtercharts.components.SelectableNode;
import com.uib.web.peptideshaker.presenter.core.form.SparkLine;
import com.vaadin.event.LayoutEvents;
import com.vaadin.server.ExternalResource;
import com.vaadin.shared.ui.MarginInfo;
import com.vaadin.shared.ui.label.ContentMode;
import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Component;
import com.vaadin.ui.Image;
import com.vaadin.ui.Label;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;
import java.awt.Color;
import java.awt.Font;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.entity.CategoryItemEntity;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.chart.renderer.category.StandardBarPainter;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.RectangleInsets;

/**
 * This class represents matrix layout filter
 *
 * @author Yehia Farag
 */
public abstract class DivaMatrixLayoutChartFilter extends VerticalLayout implements RegistrableFilter {

    /**
     * The width of the chart.
     */
    private int mainWidth;
    /**
     * The height of the chart.
     */
    private int mainHeight;
    private final String title;
    private final String filterId;
    private Map<String, Set<Comparable>> columns;
    private final Map<String, Integer> rows = new LinkedHashMap<>();
    private final Set<Comparable> fullItemsSet;
    private final SelectionManager Selection_Manager;
    private final Map<Integer, Double> barChartValues;
    private Label chartTitle;
    private Image mainChartImg;
    private Label maxScaleLabel;
    private Label minScaleLabel;
    private VerticalLayout leftBottomCorner;
    private AbsoluteLayout bottomLayoutContainer;
    private final Map<Integer, List<SelectableNode>> nodesTable;
    private AbsoluteLayout topLayoutPanel;
    private AbsoluteLayout bottomLayoutPanel;
    private boolean allowDrawing = false;
    private int index = 0;

    /**
     * The bar-chart JFree chart (required by JFree chart).
     */
    private JFreeChart chart;
    /**
     * The bar-chart rendering information generated by JFree chart and contain
     * all the chart information.
     */
    private final ChartRenderingInfo mainChartRenderingInfo = new ChartRenderingInfo();
    private AbsoluteLayout mainChartContainer;
    private final LayoutEvents.LayoutClickListener barListener;
    private AbsoluteLayout chartBarsContainer;
    private final List<VerticalLayout> chartBarsList;
//    private final Set<Comparable> selectedDataSet;
    private AbsoluteLayout columnsContainer;
    private final Map<String, SparkLine> rowLabelsMap;
    private Map<String, Color> dataColors;

    public DivaMatrixLayoutChartFilter(String title, String filterId, SelectionManager Selection_Manager) {
        this.mainWidth = 300;
        this.mainHeight = 300;
        this.title = title;
        this.filterId = filterId;
        this.Selection_Manager = Selection_Manager;
        this.rowLabelsMap = new LinkedHashMap<>();
//        this.selectedDataSet = new LinkedHashSet<>();
        this.Selection_Manager.RegistrFilter(DivaMatrixLayoutChartFilter.this);
        this.nodesTable = new LinkedHashMap<>();
        this.chartBarsList = new ArrayList<>();
        this.barChartValues = new LinkedHashMap<>();
        this.fullItemsSet = new LinkedHashSet<>();
        this.barListener = (LayoutEvents.LayoutClickEvent event) -> {
            Component clickedComponent = event.getClickedComponent();
            if (clickedComponent == null) {
                return;
            }
            if (clickedComponent instanceof VerticalLayout && !clickedComponent.getStyleName().contains("selectedbarlayout")) {
                int columnIndx = (int) ((VerticalLayout) clickedComponent).getData();
                applyFilter(columnIndx);
            } //            else if (clickedComponent instanceof Label && !clickedComponent.getStyleName().contains("selectedbubble")) {
            //                int columnIndx = (int) ((Label) clickedComponent).getData();
            //                applyFilter(columnIndx);
            //            } 
            else {
                System.out.println("---clickedComponent ---------" + clickedComponent + " ---  " + clickedComponent.getStyleName());
                applyFilter(-1);
            }
        };
        this.initlayout();

    }

    private void initlayout() {
        DivaMatrixLayoutChartFilter.this.setSizeFull();
        DivaMatrixLayoutChartFilter.this.setStyleName("thumbfilterframe");
        DivaMatrixLayoutChartFilter.this.setSpacing(true);

        topLayoutPanel = new AbsoluteLayout();
        topLayoutPanel.setSizeFull();
        DivaMatrixLayoutChartFilter.this.addComponent(topLayoutPanel);
        DivaMatrixLayoutChartFilter.this.setComponentAlignment(topLayoutPanel, Alignment.TOP_LEFT);
        DivaMatrixLayoutChartFilter.this.setExpandRatio(topLayoutPanel, 30);

        VerticalLayout topLeftCornerLayout = new VerticalLayout();
        topLeftCornerLayout.setWidth(28, Unit.PERCENTAGE);
        topLeftCornerLayout.setHeight(100, Unit.PERCENTAGE);
        topLeftCornerLayout.setMargin(new MarginInfo(false, false, false, false));
        topLayoutPanel.addComponent(topLeftCornerLayout, "left:0px;top:0px;");

        chartTitle = new Label("<font style='padding-left: 10px;padding-top: 3%;position: absolute;'>" + title + "</font>", ContentMode.HTML);
        chartTitle.setStyleName(ValoTheme.LABEL_BOLD);
        chartTitle.setWidth(100, Unit.PERCENTAGE);
        chartTitle.setHeight(100, Unit.PERCENTAGE);
        chartTitle.addStyleName("resizeabletext");
        topLeftCornerLayout.addComponent(chartTitle);
        topLeftCornerLayout.setComponentAlignment(chartTitle, Alignment.MIDDLE_LEFT);

//        HorizontalLayout scaleLayout = new HorizontalLayout();
//        scaleLayout.setWidth(100, Unit.PERCENTAGE);
//        scaleLayout.setHeight(30, Unit.PIXELS);
//        topLeftCornerLayout.addComponent(scaleLayout);
//        topLeftCornerLayout.setComponentAlignment(scaleLayout, Alignment.BOTTOM_LEFT);
//        VerticalLayout v1 = new VerticalLayout();
////        v1.addStyleName("sizelabel");
//        scaleLayout.addComponent(v1);
//        scaleLayout.setExpandRatio(v1, 0.2f);
//        
//        maxScaleLabel = new Label("<b>10000</b>");
//        maxScaleLabel.setContentMode(ContentMode.HTML);
//        maxScaleLabel.setHeight(100, Unit.PERCENTAGE);
//        maxScaleLabel.setWidth(100, Unit.PERCENTAGE);
//        maxScaleLabel.setStyleName(ValoTheme.LABEL_NO_MARGIN);
//        maxScaleLabel.addStyleName("sizelabel");
//        scaleLayout.addComponent(maxScaleLabel);
//        scaleLayout.setExpandRatio(maxScaleLabel, 1.8f);
//
//        minScaleLabel = new Label();
//        minScaleLabel.setContentMode(ContentMode.HTML);
//        minScaleLabel.setHeight(100, Unit.PERCENTAGE);
//        minScaleLabel.setWidth(100, Unit.PERCENTAGE);
//        minScaleLabel.setStyleName(ValoTheme.LABEL_NO_MARGIN);
//        minScaleLabel.addStyleName("sizelabel");
//        scaleLayout.addComponent(minScaleLabel);
//        scaleLayout.setExpandRatio(minScaleLabel, 8);
        mainChartContainer = new AbsoluteLayout();
        mainChartContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.setHeight(100, Unit.PERCENTAGE);
        topLayoutPanel.addComponent(mainChartContainer, "left:28%;top:0px;");

        mainChartImg = new Image();
        mainChartImg.setHeight(100, Unit.PERCENTAGE);
        mainChartImg.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.addComponent(mainChartImg);

        chartBarsContainer = new AbsoluteLayout();
        chartBarsContainer.setHeight(100, Unit.PERCENTAGE);
        chartBarsContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.addComponent(chartBarsContainer);
        chartBarsContainer.addStyleName("pointer");
        chartBarsContainer.addLayoutClickListener(barListener);

        SizeReporter mainSizeReporter = new SizeReporter(mainChartContainer);
        mainSizeReporter.addResizeListener((ComponentResizeEvent event) -> {

            int tWidth = event.getWidth();
            int tHeight = event.getHeight();
            if (mainWidth == tWidth && mainHeight == tHeight) {
                return;
            }
            mainWidth = tWidth;
            mainHeight = tHeight;
            redrawChart();
        });
        initChart();
        /**
         * ******************lower panel*********************
         */
        bottomLayoutPanel = new AbsoluteLayout();
        bottomLayoutPanel.setSizeFull();
        DivaMatrixLayoutChartFilter.this.addComponent(bottomLayoutPanel);
        DivaMatrixLayoutChartFilter.this.setComponentAlignment(bottomLayoutPanel, Alignment.TOP_LEFT);
        DivaMatrixLayoutChartFilter.this.setExpandRatio(bottomLayoutPanel, 70);
        bottomLayoutPanel.addStyleName("ignorscrollspace");
        bottomLayoutContainer = new AbsoluteLayout();
        bottomLayoutContainer.setWidth(100, Unit.PERCENTAGE);
        bottomLayoutPanel.addComponent(bottomLayoutContainer);
        leftBottomCorner = new VerticalLayout();
        leftBottomCorner.setStyleName("leftbottommatrexcorner");
        leftBottomCorner.setWidth(28, Unit.PERCENTAGE);
        leftBottomCorner.setHeight(100, Unit.PERCENTAGE);
        leftBottomCorner.setSpacing(false);
        columnsContainer = new AbsoluteLayout();
        columnsContainer.setHeight(100, Unit.PERCENTAGE);
        columnsContainer.setWidth(100, Unit.PERCENTAGE);
        columnsContainer.addStyleName("pointer");
    }

    public void initializeFilterData(ModificationMatrix modificationMatrix, Map<String, Color> dataColors, Set<Object> selectedCategories, int totalNumber) {
        index = 0;
        allowDrawing = false;

//        selectedDataSet.clear();
        rows.clear();
        rowLabelsMap.clear();
        this.dataColors = dataColors;
        rows.putAll(modificationMatrix.getRows());
        columns = modificationMatrix.getCalculatedMatrix();
        barChartValues.clear();
        fullItemsSet.clear();
        int coulmnIndx = 0;
        for (String key : columns.keySet()) {
            fullItemsSet.addAll(columns.get(key));
            barChartValues.put(coulmnIndx++, (double) columns.get(key).size());
        }
        updateChartDataset(barChartValues);

        int totHehight = ((rows.size() + 1) * 30);
        float expandingRatio = DivaMatrixLayoutChartFilter.this.getExpandRatio(topLayoutPanel);
        double containerHeight = mainHeight * 100.00 / expandingRatio;
        double currentBottomActualRatio = (double) (totHehight / containerHeight * 100.0) + 5.0;
        double bottomPanelRatio;
        if (currentBottomActualRatio >= 70) {
            bottomPanelRatio = 70f;
        } else if (currentBottomActualRatio > 50 && currentBottomActualRatio < 70) {
            bottomPanelRatio = currentBottomActualRatio;
        } else {
            bottomPanelRatio = 50;
        }

        double topPanelRation = 100 - bottomPanelRatio;
        DivaMatrixLayoutChartFilter.this.setExpandRatio(topLayoutPanel, (float) topPanelRation);
        DivaMatrixLayoutChartFilter.this.setExpandRatio(bottomLayoutPanel, (float) bottomPanelRatio);
        allowDrawing = true;
    }

//    private Map<String, Set<Comparable>> calculateMatrix(Map<String, Set<Comparable>> data) {
//        //calculate matrix
//        Map<String, Set<Comparable>> matrixData = new LinkedHashMap<>();
//        TreeMap<AlphanumComparator, String> sortingMap = new TreeMap<>(Collections.reverseOrder());
//        for (String key : data.keySet()) {
//            AlphanumComparator sortingKey = new AlphanumComparator(data.get(key).size() + "_" + key);
//            sortingMap.put(sortingKey, key);
//        }
//        Map<String, Set<Comparable>> sortedData = new LinkedHashMap<>();
//        for (String key : sortingMap.values()) {
//            int size = data.get(key).size();
//            this.rows.put(key, size);
//            sortedData.put(key, data.get(key));
//        }
//        Map<String, Set<Comparable>> rowsII = new LinkedHashMap<>(sortedData);
//        Map<String, Set<Comparable>> tempColumns = new LinkedHashMap<>();
//        tempColumns.putAll(sortedData);
//        Map<String, Set<Comparable>> trows = new LinkedHashMap<>(sortedData);
//        for (String keyI : sortedData.keySet()) {
//            for (String keyII : rowsII.keySet()) {
//                if (keyI.equals(keyII) || keyII.contains(keyI)) {
//                    continue;
//                }
//                String key = (keyII + "," + keyI).replace("[", "").replace("]", "");//.replace(" ", "");
//                keySorter.addAll(Arrays.asList(key.split(",")));
//                key = keySorter.toString();
//                keySorter.clear();
//                if (trows.containsKey(key)) {
//                    Set<Comparable> union = new LinkedHashSet<>();
//                    union.addAll(com.google.common.collect.Sets.union(trows.get(key), com.google.common.collect.Sets.intersection(rowsII.get(keyII), sortedData.get(keyI))));
//                    trows.put(key, union);
//                } else {
//                    Set<Comparable> intersection = new LinkedHashSet<>();
//                    intersection.addAll(com.google.common.collect.Sets.intersection(rowsII.get(keyII), sortedData.get(keyI)));
//                    trows.put(key, intersection);
//                    Set<Comparable> tempSetI = new LinkedHashSet<>();
//                    tempSetI.addAll(rowsII.get(keyII));
//                    tempSetI.removeAll(intersection);
//                    rowsII.replace(keyII, tempSetI);
//                    Set<Comparable> tempSetII = new LinkedHashSet<>();
//                    tempSetII.addAll(sortedData.get(keyI));
//                    tempSetII.removeAll(intersection);
//                    sortedData.replace(keyI, tempSetII);
//                }
//            }
//            rowsII.clear();
//            rowsII.putAll(trows);
//            tempColumns.putAll(trows);
//        }
//        Map<AlphanumComparator, String> sortingMap2 = new TreeMap<>(Collections.reverseOrder());
//        for (String key : tempColumns.keySet()) {
//            AlphanumComparator sortingKey = new AlphanumComparator(tempColumns.get(key).size() + "_" + key);
//            sortingMap2.put(sortingKey, key);
//        }
//        List<String> sortingKeysList = new ArrayList<>(rows.keySet());
//        Map<Integer, String> sortingKysMap = new TreeMap<>();
//        for (String key : sortingMap2.values()) {
//            String[] arr = key.split(",");
//            String updatedKey = key;
//            if (arr.length > 1) {
//                sortingKysMap.clear();
//                for (String sub : arr) {
//                    sub = sub.replace("]", "").replace("[", "").trim();
//                    sortingKysMap.put(sortingKeysList.indexOf(sub), sub);
//                }
//                updatedKey = sortingKysMap.values().toString();
//            }
//            if (!tempColumns.get(key).isEmpty()) {
//                matrixData.put(updatedKey, tempColumns.get(key));
//            }
//        }
//        for (String key1 : matrixData.keySet()) {
//            for (String key2 : matrixData.keySet()) {
//                HashSet<Comparable> intersction = new HashSet<>();
//                intersction.addAll(Sets.intersection(matrixData.get(key2), matrixData.get(key1)));
//                if (!intersction.isEmpty() && !key2.equalsIgnoreCase(key1)) {
//                    if (key1.split(",").length > key2.split(",").length) {
//                        matrixData.get(key2).removeAll(intersction);
//                    } else if (key1.split(",").length < key2.split(",").length) {
//                        matrixData.get(key1).removeAll(intersction);
//                    } else {
//                        matrixData.get(key1).removeAll(intersction);
//                        matrixData.get(key2).removeAll(intersction);
//                    }
//                }
//            }
//        }
//
//        Map<String, Set<Comparable>> tempMatrixData = new LinkedHashMap<>(matrixData);
//        for (String key1 : tempMatrixData.keySet()) {
//            if (matrixData.get(key1).isEmpty()) {
//                matrixData.remove(key1);
//            }
//        }
//
//        TreeMap<AlphanumComparator, String> sortingKeyColumnsMap = new TreeMap<>(Collections.reverseOrder());
//        for (String key : matrixData.keySet()) {
//            AlphanumComparator sortKey = new AlphanumComparator(matrixData.get(key).size() + "_" + key);
//            sortingKeyColumnsMap.put(sortKey, key);
//        }
//        tempMatrixData.clear();
//        for (String key : sortingKeyColumnsMap.values()) {
//            tempMatrixData.put(key, matrixData.get(key));
//        }
//        return tempMatrixData;
//    }
    private void reDrawLayout(int width, ChartRenderingInfo chartRenderingInfo) {
        //80% == width then 20% ==??
        int x = 28 * width / 72;
        columnsContainer.removeAllComponents();
        chartBarsContainer.removeAllComponents();
        bottomLayoutContainer.removeAllComponents();
        bottomLayoutContainer.setHeight(((rows.size() + 1) * 30), Unit.PIXELS);
        bottomLayoutContainer.addComponent(leftBottomCorner, "left:0px;top:0px;");
        bottomLayoutContainer.addComponent(columnsContainer, "left:" + x + "px;top:0px;");
        leftBottomCorner.removeAllComponents();
        nodesTable.clear();
        chartBarsList.clear();
        int columnPreIndex = 0;
        Integer[] reIndexing = barChartValues.keySet().toArray(new Integer[barChartValues.size()]);
        for (int i = 0; i < chartRenderingInfo.getEntityCollection().getEntityCount(); i++) {
            ChartEntity ent = chartRenderingInfo.getEntityCollection().getEntity(i);
            if (ent instanceof CategoryItemEntity) {
                CategoryItemEntity catEnt = (CategoryItemEntity) ent;
                Rectangle rect = catEnt.getArea().getBounds();
                VerticalLayout column = new VerticalLayout();
                column.setWidth(rect.width, Unit.PIXELS);
                column.setHeight(100, Unit.PERCENTAGE);
                column.addStyleName("selectablenode");
                column.addStyleName("bordermarker");
                column.setSpacing(false);
                columnsContainer.addComponent(column, "left:" + rect.x + "px; top:" + 0 + "px;");
                //init basic nodes
                int columnIndex = reIndexing[columnPreIndex++];
                for (String rowKey : rows.keySet()) {
                    String columnKey = columns.keySet().toArray()[columnIndex] + "";
                    if (!nodesTable.containsKey(columnIndex)) {
                        nodesTable.put(columnIndex, new ArrayList<>());
                    }
                    SelectableNode node = new SelectableNode(rowKey, columnIndex, columns.get(columnKey).isEmpty(), dataColors.get(rowKey)) {
                        @Override
                        public void selectNode(int columnIndex) {
//                            System.out.println("at selected node style " + this.getStyleName());
                            applyFilter(columnIndex);
                        }
                    };
                    node.setData(columns.get(columnKey).size());
                    node.setDescription(columnKey);
                    nodesTable.get(columnIndex).add(node);
                    column.addComponent(node);
                    column.setComponentAlignment(node, Alignment.TOP_LEFT);

                }

                VerticalLayout bar = new VerticalLayout();
                bar.setWidth(rect.width, Unit.PIXELS);
                bar.setHeight(rect.height, Unit.PIXELS);
                bar.setStyleName("barlayout");
                bar.setData(columnIndex);
                bar.setDescription(columns.keySet().toArray()[columnIndex++] + "");
                chartBarsContainer.addComponent(bar, "left:" + rect.x + "px; top:" + rect.y + "px;");
                chartBarsList.add(bar);

            }

        }
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int i : rows.values()) {
            if (max < i) {
                max = i;
            }
            if (min > i) {
                min = i;
            }
        }
//        maxScaleLabel.setValue("<b>" + max + "</b>");
//        minScaleLabel.setValue(" <font>" + min + "</font>");
        int rowIndex = 0;
        for (String rowKey : rows.keySet()) {
            SparkLine sl = new SparkLine(rowKey, rows.get(rowKey), 0, max, dataColors.get(rowKey));
            sl.setData(rowIndex);
            sl.setDescription(rowKey);
            leftBottomCorner.addComponent(sl);
            leftBottomCorner.setComponentAlignment(sl, Alignment.TOP_LEFT);
            rowLabelsMap.put(rowKey, sl);

            List<String> sortingKeysList = new ArrayList<>(rows.keySet());
            for (int columnIndex : barChartValues.keySet()) {
                String columnKey = columns.keySet().toArray()[columnIndex] + "";
                String[] subArr = columnKey.replace("]", "").replace("[", "").trim().split(",");
                int startLineRange = sortingKeysList.indexOf(subArr[0]);
                int endLineRange = sortingKeysList.indexOf(subArr[subArr.length - 1].trim());
                if (!nodesTable.containsKey(columnIndex) || nodesTable.get(columnIndex).get(rowIndex) == null) {
                    columnPreIndex++;
                    continue;
                }
                SelectableNode node = nodesTable.get(columnIndex).get(rowIndex);
                if (columnKey.contains(node.getNodeId())) {
                    node.setSelecatble(true);
                    node.setUpperSelected(true);
                    node.setLowerSelected(true);
                } else {
                    node.setSelecatble(false);
                }
                if (columnKey.split(",").length == 1) {
                    node.setUpperSelected(false);
                    node.setLowerSelected(false);
                } else {
                    int nodeIndex = sortingKeysList.indexOf(node.getNodeId());
                    if (nodeIndex == startLineRange) {
                        node.setUpperSelected(false);
                        node.setLowerSelected(true);
                    } else if (nodeIndex > startLineRange && nodeIndex < endLineRange) {
                        node.setUpperSelected(true);
                        node.setLowerSelected(true);
                    } else if (nodeIndex == endLineRange) {
                        node.setUpperSelected(true);
                        node.setLowerSelected(false);
                    } else {
                        node.setUpperSelected(false);
                        node.setLowerSelected(false);
                    }
                }
                columnPreIndex++;
            }
            rowIndex++;
        }

    }

    private void selectColumn(int columnIndex) {
        String columnId = columns.keySet().toArray()[columnIndex] + "";
        Set<Comparable> columnIds = new LinkedHashSet<>();
        columnIds.add(columnId);
        selectColumn(columnIds, columnIndex);
    }

    private void selectColumn(Set<Comparable> columnIds) {
        if (columnIds.isEmpty()) {
            unselectAll();
            return;
        }
        List<String> indexer = new ArrayList<>();
        for (int i : barChartValues.keySet()) {
            indexer.add(columns.keySet().toArray()[i] + "");
        }

        selectColumn(columnIds, indexer.indexOf(columnIds.iterator().next()));
    }

    private void selectColumn(Set<Comparable> columnId, int columnIndex) {

        if (nodesTable.get(columnIndex).get(0).isSelected()) {
            unselectAll();
            return;
        }
        unselectAll();
        for (SparkLine sL : rowLabelsMap.values()) {
            sL.setSelected(columnId.contains(sL.getDescription()));
        }
        for (SelectableNode sN : nodesTable.get(columnIndex)) {
            sN.setSelected(true);
        }
        chartBarsList.get(columnIndex).addStyleName("selectedbarlayout");
        System.out.println("¨at column index " + columnId + "  " + columnIndex + "   " + chartBarsList.get(columnIndex).getStyleName());

        {

        }
    }

    private void unselectAll() {
        for (SparkLine sL : rowLabelsMap.values()) {
            sL.setSelected(false);
        }
        for (VerticalLayout bar : chartBarsList) {
            bar.removeStyleName("selectedbarlayout");
        }
        for (List<SelectableNode> lSN : nodesTable.values()) {
            for (SelectableNode sN : lSN) {
                sN.setSelected(false);

            }
        }
    }

    @Override
    public void redrawChart() {
        if (allowDrawing && index++ > 0) {
            mainChartImg.setSource(new ExternalResource(saveToFile(chart, mainChartRenderingInfo, mainWidth, mainHeight)));
            reDrawLayout(mainWidth, mainChartRenderingInfo);
        }
    }

    @Override
    public String getFilterId() {
        return filterId;
    }

    @Override
    public void updateFilterSelection(Set<Comparable> selectedItems, Set<Comparable> selectedCategories, boolean topFilter, boolean singleProteinsFilter, boolean selfAction) {

        //case 1 self selection (select coulmn or unselect all)
        if (!selfAction) {
            if (singleProteinsFilter && !selfAction && !selectedCategories.isEmpty()) {
                 barChartValues.clear();
                 int coulmnIndex = 0;
                for (String key : columns.keySet()) {
                    double d = (double) columns.get(key).size();
                    barChartValues.put(coulmnIndex, d);
                    coulmnIndex++;
                }
                updateChartDataset(barChartValues);
                redrawChart();

            } else {
                Map<Integer, Double> tbarChartValues = new LinkedHashMap<>();
                int coulmnIndex = 0;
                for (String key : columns.keySet()) {
                    double d = (double) Sets.intersection(columns.get(key), selectedItems).size();
                    if (d > 0) {
                        tbarChartValues.put(coulmnIndex, d);
                    }
                    coulmnIndex++;
                }
                barChartValues.clear();
                barChartValues.putAll(tbarChartValues);
                updateChartDataset(barChartValues);
                redrawChart();//
            }
        }

        selectColumn(selectedCategories);

    }

    public void applyFilter(int columnIndex) {
        Set<Comparable> appliedFilter = new LinkedHashSet<>();
        if (columnIndex == -1) {
            Selection_Manager.setSelection("protein_selection", appliedFilter, null, filterId);
            return;
        }
        appliedFilter.add((columns.keySet().toArray()[columnIndex] + ""));
        Selection_Manager.setSelection("protein_selection", appliedFilter, null, filterId);
    }

    /**
     * Convert JFree chart into image and encode it as base64 string to be used
     * as image link.
     *
     * @param chart JFree chart instance
     * @param width Image width
     * @param height Image height.
     */
    private String saveToFile(final JFreeChart chart, ChartRenderingInfo chartRenderingInfo, int width, int height) {
        if (width < 1 || height < 1) {
            width = 1;
            height = 1;
        }
        byte imageData[];
        try {
            chart.getLegend().setVisible(false);
            imageData = ChartUtilities.encodeAsPNG(chart.createBufferedImage(width, height, chartRenderingInfo));
            String base64 = Base64.encodeBytes(imageData);
            base64 = "data:image/png;base64," + base64;
            return base64;
        } catch (IOException e) {
            System.err.println("at error " + e.getMessage());
        }
        return "";
    }

    /**
     * Initialize the main JFree chart component.
     */
    private void initChart() {
        // create the dataset...
        DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        CategoryAxis domainAxis = new CategoryAxis();
        Font labelFont = new Font("\"Open Sans\", sans-serif", Font.BOLD, 11);

        domainAxis.setTickLabelFont(labelFont);
        domainAxis.setTickLabelPaint(Color.GRAY);
        domainAxis.setTickLabelsVisible(false);
        domainAxis.setTickMarksVisible(false);

        NumberAxis rangeAxis = new NumberAxis();
        rangeAxis.setTickLabelFont(labelFont);
        rangeAxis.setTickLabelPaint(Color.GRAY);
        rangeAxis.setUpperMargin(0.3);
        rangeAxis.setTickLabelsVisible(false);
        rangeAxis.setTickMarksVisible(false);
        rangeAxis.setVisible(false);
        rangeAxis.setAxisLineVisible(false);

        BarRenderer renderer = new BarRenderer();
        renderer.setBaseItemLabelGenerator(new StandardCategoryItemLabelGenerator() {
            @Override
            public String generateLabel(CategoryDataset dataset, int row, int column) {

                int key = barChartValues.keySet().toArray(new Integer[barChartValues.size()])[column];
                return ((int) ((double) barChartValues.get(key))) + "";//super.generateLabel(dataset, row, column); //To change body of generated methods, choose Tools | Templates.
            }
        });
        renderer.setBaseItemLabelsVisible(true);
        renderer.setBarPainter(new StandardBarPainter());
        renderer.setSeriesPaint(0, Color.WHITE);
        renderer.setShadowVisible(false);
        renderer.setBaseItemLabelFont(labelFont);
        renderer.setBaseItemLabelPaint(Color.GRAY);

        CategoryPlot plot = new CategoryPlot(dataset, domainAxis, rangeAxis, renderer);
        plot.setNoDataMessage("No data available");
        plot.setOutlineVisible(false);
        plot.setDomainGridlinesVisible(false);
        plot.setRangeGridlinesVisible(false);

        plot.getDomainAxis().setLowerMargin(0.0D);
        plot.getDomainAxis().setUpperMargin(0.0D);

        plot.setBackgroundPaint(Color.WHITE);
        chart = new JFreeChart(plot);
        chart.setPadding(new RectangleInsets(0.0, 0.0, 0.0, 5));
        chart.setBorderPaint(null);
        chart.setBackgroundPaint(null);
        chart.getLegend().setFrame(BlockBorder.NONE);

    }

    private void updateChartDataset(Map<Integer, Double> barChartData) {
        // column keys...    
        int counter = 0;
        // update the dataset...
        DefaultCategoryDataset dataset = (DefaultCategoryDataset) ((CategoryPlot) chart.getPlot()).getDataset();
        dataset.clear();
        for (double d : barChartData.values()) {
            dataset.addValue(scaleValues(d, 100, 20), "protData", (counter++) + "");

        }
//        redrawChart();

    }

    /**
     * Converts the value from linear scale to log scale. The log scale numbers
     * are limited by the range of the type float. The linear scale numbers can
     * be any double value.
     *
     * @param linearValue the value to be converted to log scale
     * @param max The upper limit number for the input numbers
     * @param lowerLimit the lower limit for the input numbers
     * @return the value in log scale
     */
    private double scaleValues(double linearValue, double max, double lowerLimit) {
        double logMax = (Math.log(max) / Math.log(2));
        double logValue = (Math.log(linearValue) / Math.log(2));
        logValue = ((max / logMax) * logValue) + lowerLimit;//(max/Math.log(max))*Math.log(linearValue)+10;
        return logValue;

//        return Math.min(logValue, max);
    }

}
