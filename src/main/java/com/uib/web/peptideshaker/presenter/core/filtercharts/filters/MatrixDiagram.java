package com.uib.web.peptideshaker.presenter.core.filtercharts.filters;

import com.ejt.vaadin.sizereporter.ComponentResizeEvent;
import com.ejt.vaadin.sizereporter.SizeReporter;
import com.google.common.collect.Sets;
import com.itextpdf.text.pdf.codec.Base64;

import com.uib.web.peptideshaker.model.core.ModificationMatrix;
import com.uib.web.peptideshaker.presenter.core.filtercharts.components.SelectableNode;
import com.uib.web.peptideshaker.presenter.core.form.SparkLine;
import com.vaadin.event.FieldEvents;
import com.vaadin.event.FieldEvents.TextChangeListener;
import com.vaadin.event.LayoutEvents;
import com.vaadin.icons.VaadinIcons;
import com.vaadin.server.ExternalResource;
import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.AbstractTextField;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Component;
import com.vaadin.ui.Image;
import com.vaadin.ui.TextField;
import com.vaadin.ui.VerticalLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.entity.CategoryItemEntity;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.chart.renderer.category.StandardBarPainter;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.RectangleInsets;

/**
 * This class represents matrix layout filter
 *
 * @author Yehia Farag
 */
public abstract class MatrixDiagram extends AbsoluteLayout {

    /**
     * The width of the filter container.
     */
    private int mainWidth;
    /**
     * The height of the filter container.
     */
    private int mainHeight;
    /**
     * The title text of the filter.
     */
    private Map<String, Set<Comparable>> columns;
    private final Map<String, Integer> rows = new LinkedHashMap<>();
    private final Set<Comparable> fullItemsSet;
    private final Map<Integer, Double> barChartValues;
    private Image mainChartImg;
    private VerticalLayout leftBottomCorner;
    private AbsoluteLayout bottomLayoutContainer;
    private final Map<Comparable, List<SelectableNode>> nodesTable;
    private AbsoluteLayout topLayoutPanel;
    private AbsoluteLayout bottomLayoutPanel;
    private boolean allowDrawing = false;
    private int index = 0;

    /**
     * The bar-chart JFree chart (required by JFree chart).
     */
    private JFreeChart chart;
    /**
     * The bar-chart rendering information generated by JFree chart and contain
     * all the chart information.
     */
    private final ChartRenderingInfo mainChartRenderingInfo = new ChartRenderingInfo();
    private final List<Runnable> tasks;
    private AbsoluteLayout mainChartContainer;
    private final LayoutEvents.LayoutClickListener barListener;
    private AbsoluteLayout chartBarsContainer;
    private final Map<Comparable, VerticalLayout> chartBarsList;
    private AbsoluteLayout columnsContainer;
    private final Map<String, SparkLine> rowLabelsMap;
    private Map<String, Color> dataColors;
    private final Set<Integer> selectedIndexes;

    public MatrixDiagram() {
        this.mainWidth = 300;
        this.mainHeight = 300;
        tasks = new ArrayList<>();
        this.rowLabelsMap = new LinkedHashMap<>();
        this.nodesTable = new LinkedHashMap<>();
        this.chartBarsList = new HashMap<>();
        this.barChartValues = new LinkedHashMap<>();
        this.fullItemsSet = new LinkedHashSet<>();
        this.selectedIndexes = new LinkedHashSet<>();
        MatrixDiagram.this.addStyleName("slowredraw");
        this.barListener = (LayoutEvents.LayoutClickEvent event) -> {
            Component clickedComponent = event.getClickedComponent();
            if (clickedComponent == null) {
                return;
            }
            if (clickedComponent instanceof VerticalLayout) {
                int columnIndx = (int) ((VerticalLayout) clickedComponent).getData();
                if (selectedIndexes.contains(columnIndx)) {
                    selectedIndexes.remove(columnIndx);
                } else {
                    selectedIndexes.add(columnIndx);
                }

            } else {
                selectedIndexes.clear();
            }
            applyFilter(selectedIndexes);
        };
        this.initlayout();

    }

    private void initlayout() {
        TextField controllerFileld = new TextField() {
            int index;

            @Override
            protected void setInternalValue(String newValue) {
                Map<String, Object> variables = new HashMap<>();
                variables.put("c", index++);
                variables.put("curText", newValue);
                changeVariables(null, variables);
                super.setInternalValue(newValue); //To change body of generated methods, choose Tools | Templates.
            }

            @Override
            public void changeVariables(Object source, Map<String, Object> variables) {
                System.out.println("change variables " + source + "   " + variables);
                super.changeVariables(source, variables); //To change body of generated methods, choose Tools | Templates.
            }

        };
        controllerFileld.setTextChangeTimeout(15000);
        controllerFileld.setTextChangeEventMode(AbstractTextField.TextChangeEventMode.LAZY);
        controllerFileld.focus();
//        controllerFileld.addTextChangeListener(new FieldEvents.TextChangeListener() {
//            @Override
//            public void textChange(FieldEvents.TextChangeEvent event) {
//                System.out.println("rezise is actually working and value is " + event.getText());
//            }
//        });

       final TextChangeListener tx = new FieldEvents.TextChangeListener() {
            @Override
            public void textChange(FieldEvents.TextChangeEvent event) {
                System.out.println("at text change " + event.getText());
            }
        };
controllerFileld.addTextChangeListener(tx);
        topLayoutPanel = new AbsoluteLayout();
        topLayoutPanel.setHeight(100, Unit.PERCENTAGE);
        topLayoutPanel.setWidth(100, Unit.PERCENTAGE);
        MatrixDiagram.this.addComponent(topLayoutPanel, "left:0px; top:0px;bottom:60%;");
        mainChartContainer = new AbsoluteLayout();
        mainChartContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.setHeight(100, Unit.PERCENTAGE);
        topLayoutPanel.addComponent(mainChartContainer, "left:28%;top:0px;");

        mainChartImg = new Image();
        mainChartImg.setHeight(100, Unit.PERCENTAGE);
        mainChartImg.setWidth(100, Unit.PERCENTAGE);

        mainChartContainer.addComponent(mainChartImg);
        mainChartImg.addStyleName("hide");
        chartBarsContainer = new AbsoluteLayout();
        chartBarsContainer.setHeight(100, Unit.PERCENTAGE);
        chartBarsContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.addComponent(chartBarsContainer);
        chartBarsContainer.addStyleName("pointer");
        chartBarsContainer.addLayoutClickListener(barListener);

        SizeReporter mainSizeReporter = new SizeReporter(mainChartContainer);

        mainSizeReporter.addResizeListener((ComponentResizeEvent event) -> {
            int tChartWidth = event.getWidth();
            int tChartHeight = event.getHeight();
            if (tChartWidth <= 0 || tChartHeight <= 0) {
                return;
            }

            if ((tChartWidth == mainWidth || Math.abs(tChartWidth - mainWidth) < 10) && (mainHeight == tChartHeight || Math.abs(tChartHeight - mainHeight) < 10)) {
                System.out.println("at redraw is cancelled");
                return;
            }
            mainWidth = tChartWidth;
            mainHeight = tChartHeight;

            controllerFileld.commit();
            controllerFileld.setResponsive(true);
            controllerFileld.setImmediate(true);
//            controllerFileld.setValue(tChartWidth + "   " + tChartHeight);
            System.out.println("---------------size " + tChartWidth + "   " + tChartHeight + "  ");
            tx.textChange(new FieldEvents.TextChangeEvent(controllerFileld) {
                @Override
                public String getText() {
                    return "Kokowawa "+tChartWidth + "   " + tChartHeight ;
                }
                
                @Override
                public int getCursorPosition() {
                   return 2;
                }
            });
//            ExecutorService executorService = Executors.newSingleThreadExecutor();
//            try {
//                executorService.awaitTermination(3, TimeUnit.SECONDS);
//            } catch (InterruptedException ex) {
//                ex.printStackTrace();
//            }
//            executorService.submit(this::redrawChart);
//            executorService.shutdown();
//            redrawChart();

//            
        });
        initChart();
        /**
         * ******************lower panel*********************
         */
        bottomLayoutPanel = new AbsoluteLayout();
        bottomLayoutPanel.setSizeFull();
        MatrixDiagram.this.addComponent(bottomLayoutPanel, "left:0px; bottom:0px; top:40%;");
        bottomLayoutPanel.addStyleName("ignorscrollspace");
        bottomLayoutContainer = new AbsoluteLayout();
        bottomLayoutContainer.setWidth(100, Unit.PERCENTAGE);
        bottomLayoutPanel.addComponent(bottomLayoutContainer);
        leftBottomCorner = new VerticalLayout();
        leftBottomCorner.setStyleName("leftbottommatrexcorner");
        leftBottomCorner.setWidth(28, Unit.PERCENTAGE);
        leftBottomCorner.setHeight(100, Unit.PERCENTAGE);
        leftBottomCorner.setSpacing(false);
        columnsContainer = new AbsoluteLayout();
        columnsContainer.setHeight(100, Unit.PERCENTAGE);
        columnsContainer.setWidth(100, Unit.PERCENTAGE);
        columnsContainer.addStyleName("pointer");

        this.addComponent(controllerFileld);
    }

    public void initializeFilterData(ModificationMatrix modificationMatrix, Map<String, Color> dataColors, Set<Object> selectedCategories, int totalNumber) {
        index = 0;
        allowDrawing = false;
        rows.clear();
        rowLabelsMap.clear();
        this.dataColors = dataColors;
        rows.putAll(modificationMatrix.getRows());
        columns = modificationMatrix.getCalculatedColumns();
        barChartValues.clear();
        fullItemsSet.clear();
        int coulmnIndx = 0;
        for (String key : columns.keySet()) {
            fullItemsSet.addAll(columns.get(key));
            barChartValues.put(coulmnIndx++, (double) columns.get(key).size());
        }
        updateChartDataset(barChartValues);
        allowDrawing = true;
    }

    private void reDrawLayout(int width, ChartRenderingInfo chartRenderingInfo) {
        int x = 28 * width / 72;
        columnsContainer.removeAllComponents();
        chartBarsContainer.removeAllComponents();
        bottomLayoutContainer.removeAllComponents();
        int finalRowNumbers = 0;
        finalRowNumbers = rows.keySet().stream().filter((rowKey) -> !(rows.get(rowKey) == 0)).map((_item) -> 1).reduce(finalRowNumbers, Integer::sum);

        bottomLayoutContainer.setHeight(((finalRowNumbers + 1) * 30), Unit.PIXELS);
        bottomLayoutContainer.addComponent(leftBottomCorner, "left:0px;top:0px;");
        bottomLayoutContainer.addComponent(columnsContainer, "left:" + x + "px;top:0px;");
        leftBottomCorner.removeAllComponents();
        nodesTable.clear();
        chartBarsList.clear();
        int columnPreIndex = 0;
        Integer[] reIndexing = barChartValues.keySet().toArray(new Integer[barChartValues.size()]);
        for (int i = 0; i < chartRenderingInfo.getEntityCollection().getEntityCount(); i++) {
            ChartEntity ent = chartRenderingInfo.getEntityCollection().getEntity(i);
            if (ent instanceof CategoryItemEntity) {
                CategoryItemEntity catEnt = (CategoryItemEntity) ent;
                Rectangle rect = catEnt.getArea().getBounds();
                VerticalLayout column = new VerticalLayout();
                column.setWidth(rect.width, Unit.PIXELS);
                column.setHeight(100, Unit.PERCENTAGE);
                column.addStyleName("selectablenode");
                column.addStyleName("bordermarker");
                column.setSpacing(false);
                columnsContainer.addComponent(column, "left:" + rect.x + "px; top:" + 0 + "px;");
                //init basic nodes
                int columnIndex = reIndexing[columnPreIndex++];
                String columnKey = columns.keySet().toArray()[columnIndex] + "";
                if (!nodesTable.containsKey(columnKey)) {
                    nodesTable.put(columnKey, new ArrayList<>());
                }
                for (String rowKey : rows.keySet()) {
                    if (rows.get(rowKey) == 0) {
                        continue;
                    }
                    SelectableNode node = new SelectableNode(rowKey, columnIndex, columns.get(columnKey).isEmpty(), dataColors.get(rowKey)) {
                        @Override
                        public void selectNode(int columnIndex) {
//                           
                            if (selectedIndexes.contains(columnIndex)) {
                                selectedIndexes.remove(columnIndex);
                            } else {
                                selectedIndexes.add(columnIndex);
                            }
                            applyFilter(selectedIndexes);
                        }
                    };
                    node.setData(columns.get(columnKey).size());
                    node.setDescription(columnKey);
                    nodesTable.get(columnKey).add(node);
                    column.addComponent(node);
                    column.setComponentAlignment(node, Alignment.TOP_LEFT);
                }

                VerticalLayout bar = new VerticalLayout();
                bar.setWidth(rect.width, Unit.PIXELS);
                bar.setHeight(rect.height, Unit.PIXELS);
                bar.setStyleName("barlayout");
                bar.setData(columnIndex);
                String mod = columns.keySet().toArray()[columnIndex++].toString().replace("[", "").replace("]", "<br/>").replace(",", "<br/>") + "<font style='font-size:10px !important;margin-right:5px'> " + VaadinIcons.HASH.getHtml() + "</font>Proteins" + "" + ((int) (double) barChartValues.get(columnIndex - 1)) + "";
                for (String key : dataColors.keySet()) {
                    if (mod.contains(key)) {
                        Color c = dataColors.get(key);
                        mod = mod.replace(key, "<font style='color:rgb(" + c.getRed() + "," + c.getGreen() + "," + c.getBlue() + ");font-size:10px !important;margin-right:5px'> " + VaadinIcons.CIRCLE.getHtml() + "</font>" + key);
                    }

                }
                bar.setDescription(mod);
                chartBarsContainer.addComponent(bar, "left:" + rect.x + "px; top:" + rect.y + "px;");
                chartBarsList.put(columnKey, bar);

            }

        }
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int i : rows.values()) {
            if (max < i) {
                max = i;
            }
            if (min > i) {
                min = i;
            }
        }

        int rowIndex = 0;
        for (String rowKey : rows.keySet()) {
            if (rows.get(rowKey) == 0) {
                continue;
            }
            SparkLine sl = new SparkLine(rowKey, rows.get(rowKey), 0, max, dataColors.get(rowKey));
            sl.setData(rowIndex);
            sl.setDescription(rowKey);
            leftBottomCorner.addComponent(sl);
            leftBottomCorner.setComponentAlignment(sl, Alignment.TOP_LEFT);
            rowLabelsMap.put(rowKey, sl);
            List<String> sortedKeysList = new ArrayList<>(rows.keySet());
            for (int columnIndex : barChartValues.keySet()) {
                String columnKey = columns.keySet().toArray()[columnIndex] + "";
                String[] subArr = columnKey.replace("]", "").replace("[", "").trim().split(",");
                int startLineRange = sortedKeysList.indexOf(subArr[0]);
                int endLineRange = sortedKeysList.indexOf(subArr[subArr.length - 1].trim());
                if (!nodesTable.containsKey(columnKey) || nodesTable.get(columnKey).get(rowIndex) == null) {
                    columnPreIndex++;
                    continue;
                }
                SelectableNode node = nodesTable.get(columnKey).get(rowIndex);
                if (columnIndex == 4) {

                }
                if (columnKey.contains(node.getNodeId())) {
                    node.setSelecatble(true);
                    node.setUpperSelected(true);
                    node.setLowerSelected(true);
                } else {
                    node.setSelecatble(false);
                }
                if (columnKey.split(",").length == 1) {
                    node.setUpperSelected(false);
                    node.setLowerSelected(false);
                } else {
                    int nodeIndex = sortedKeysList.indexOf(node.getNodeId());
                    if (nodeIndex == startLineRange) {
                        node.setUpperSelected(false);
                        node.setLowerSelected(true);
                    } else if (nodeIndex > startLineRange && nodeIndex < endLineRange) {
                        node.setUpperSelected(true);
                        node.setLowerSelected(true);
                    } else if (nodeIndex == endLineRange) {
                        node.setUpperSelected(true);
                        node.setLowerSelected(false);
                    } else {
                        node.setUpperSelected(false);
                        node.setLowerSelected(false);
                    }
                }
                columnPreIndex++;
            }
            rowIndex++;
        }

    }

    private void selectColumn(Set<Comparable> columnIds) {
        unselectAll();
        if (columnIds.isEmpty()) {
            return;
        }
//        String columnId = columnIds.iterator().next() + "";
        columnIds.stream().map((columnId) -> {
            //            if (nodesTable.get(columnId).get(0).isSelected()) {
//                continue;
//            }
            rowLabelsMap.values().forEach((sL) -> {
                if (columnId.toString().contains(sL.getDescription())) {
                    sL.setSelected(true);
                }
            });
            return columnId;
        }).map((columnId) -> {
            nodesTable.get(columnId).forEach((sN) -> {
                sN.setSelected(true);
            });
            return columnId;
        }).forEachOrdered((columnId) -> {
            chartBarsList.get(columnId).addStyleName("selectedbarlayout");
        });

    }

    public void unselectAll() {

        rowLabelsMap.values().forEach((sL) -> {
            sL.setSelected(false);
        });
        chartBarsList.values().forEach((bar) -> {
            bar.removeStyleName("selectedbarlayout");
        });
        nodesTable.values().forEach((lSN) -> {
            lSN.forEach((sN) -> {
                sN.setSelected(false);
            });
        });
    }

    public void resetFilter() {
        selectedIndexes.clear();
        unselectAll();

    }
    private Future redrawRunFuture;

    public void redrawChart() {
        if (allowDrawing && index++ > 0) {

            try {

//                allowDrawing = false;
//                tasks.add((Runnable) () -> {
//                addStyleName("hidematrix");
                System.out.println("updddating charttttt re submitt");
                mainChartImg.setSource(new ExternalResource(saveToFile(chart, mainChartRenderingInfo, mainWidth, mainHeight)));
                mainChartImg.removeStyleName("hide");
                reDrawLayout(mainWidth, mainChartRenderingInfo);
//                });
//
//                System.out.println("<<<<<<<<<<<<<<<<<<excuted>>>>>>>>>>>>>>>>>>>>>");
//                ExecutorService executorService = Executors.newSingleThreadExecutor();
//                redrawRunFuture = executorService.submit(tasks.get(tasks.size() - 1));
//                executorService.shutdown();
//                tasks.clear();
//                while (!redrawRunFuture.isDone()) {
//
//                }
                removeStyleName("hidematrix");

//                executorService.shutdownNow();
//                executorService = Executors.newSingleThreadExecutor();
//                executorService.awaitTermination(2, TimeUnit.SECONDS);
//                System.out.println("at a call to redraw");
//                if (redrawRunFuture != null) {
//                    System.out.println("----->redraw cancelled" + redrawRunFuture.cancel(true));
////                    redrawRun.cancel(true);
//                }
//                System.out.println("---->> hide panel");
//                System.out.println("--->> new style " + getStyleName());
//                redrawRunFuture = executorService.submit(() -> {
//                    addStyleName("hidematrix");
//                    System.out.println("at re submitt");
//                    mainChartImg.setSource(new ExternalResource(saveToFile(chart, mainChartRenderingInfo, mainWidth, mainHeight)));
//                    mainChartImg.removeStyleName("hide");
//                    reDrawLayout(mainWidth, mainChartRenderingInfo);
//                });
//                while (!redrawRunFuture.isDone()) {
////                    System.out.println("at results r is not done ");
//                }
//                System.out.println("at results r is  done :-D " + redrawRunFuture);
//                this.removeStyleName("hidematrix");
//                this.markAsDirty();
//                System.out.println("--->> new style " + getStyleName());
            } catch (Exception ex) {
                ex.printStackTrace();
                this.removeStyleName("hidematrix");
            }

        }
    }
//    ExecutorService executorService = Executors.newSingleThreadExecutor();

    public void updateFilterSelection(Set<Comparable> selectedItems, Set<Comparable> selectedCategories, boolean topFilter, boolean singleProteinsFilter, boolean selfAction) {
        if (!selfAction) {
            barChartValues.clear();
            if (singleProteinsFilter && !selfAction && !selectedCategories.isEmpty()) {
                int coulmnIndex = 0;
                for (String key : columns.keySet()) {
                    double d = (double) columns.get(key).size();
                    barChartValues.put(coulmnIndex, d);
                    coulmnIndex++;
                }
            } else {
                Map<Integer, Double> tbarChartValues = new LinkedHashMap<>();
                int coulmnIndex = 0;
                for (String key : columns.keySet()) {
                    double d = (double) Sets.intersection(columns.get(key), selectedItems).size();
                    if (d > 0) {
                        tbarChartValues.put(coulmnIndex, d);
                    }
                    coulmnIndex++;
                }
                barChartValues.putAll(tbarChartValues);

            }
            updateChartDataset(barChartValues);
            redrawChart();
        }
        setMainAppliedFilter(topFilter && !selectedCategories.isEmpty());
        selectColumn(selectedCategories);
    }

    public Set<Comparable> filterAction(Set<Integer> columnIndexs) {
        if (chartBarsList.size() == 1 || columnIndexs == null || columnIndexs.isEmpty()) {
            return null;
        }
        Set<Comparable> appliedFilter = new LinkedHashSet<>();
        columnIndexs.forEach((columnIndex) -> {
            appliedFilter.add((columns.keySet().toArray()[columnIndex] + ""));
        });
        return appliedFilter;
    }

    /**
     * Convert JFree chart into image and encode it as base64 string to be used
     * as image link.
     *
     * @param chart JFree chart instance
     * @param width Image width
     * @param height Image height.
     */
    private String saveToFile(final JFreeChart chart, ChartRenderingInfo chartRenderingInfo, int width, int height) {
        if (width < 1 || height < 1) {
            width = 1;
            height = 1;
        }
        byte imageData[];
        try {
            double barArea = (double) width / Math.max((double) ((CategoryPlot) chart.getPlot()).getDataset().getColumnCount(), 4);
            double barWidth = (10.0 / barArea) / 2.0;
            ((BarRenderer) ((CategoryPlot) chart.getPlot()).getRenderer()).setMaximumBarWidth(barWidth);//(50.0 / (double) width));
            chart.getLegend().setVisible(false);
            imageData = ChartUtilities.encodeAsPNG(chart.createBufferedImage(width, height, chartRenderingInfo));
            String base64 = Base64.encodeBytes(imageData);
            base64 = "data:image/png;base64," + base64;
            return base64;
        } catch (IOException e) {
            System.err.println("at error " + e.getMessage());
        }
        return "";
    }

    /**
     * Initialise the main JFree chart component.
     */
    private void initChart() {
        // create the dataset...
        DefaultCategoryDataset dataset = new DefaultCategoryDataset();

        CategoryAxis domainAxis = new CategoryAxis();
        Font labelFont = new Font("\"Open Sans\", sans-serif", Font.PLAIN, 11);

        domainAxis.setTickLabelFont(labelFont);
        domainAxis.setTickLabelPaint(Color.GRAY);
        domainAxis.setTickLabelsVisible(false);
        domainAxis.setTickMarksVisible(false);

        NumberAxis rangeAxis = new NumberAxis();
        rangeAxis.setTickLabelFont(labelFont);
        rangeAxis.setTickLabelPaint(Color.GRAY);
        rangeAxis.setUpperMargin(0.17);
        rangeAxis.setTickLabelsVisible(false);
        rangeAxis.setTickMarksVisible(false);
        rangeAxis.setVisible(false);
        rangeAxis.setAxisLineVisible(false);

        BarRenderer renderer = new BarRenderer();
        renderer.setBaseItemLabelGenerator(new StandardCategoryItemLabelGenerator() {
            @Override
            public String generateLabel(CategoryDataset dataset, int row, int column) {

                int key = barChartValues.keySet().toArray(new Integer[barChartValues.size()])[column];
                return ((int) ((double) barChartValues.get(key))) + "";//super.generateLabel(dataset, row, column); //To change body of generated methods, choose Tools | Templates.
            }
        });

        renderer.setBaseItemLabelsVisible(true);
        renderer.setBarPainter(new StandardBarPainter());
        renderer.setSeriesPaint(0, Color.WHITE);
        renderer.setShadowVisible(false);
        renderer.setBaseItemLabelFont(labelFont);
        renderer.setBaseItemLabelPaint(Color.GRAY);
        renderer.setMaximumBarWidth(1);
//        renderer.setMinimumBarLength(0.5);

        CategoryPlot plot = new CategoryPlot(dataset, domainAxis, rangeAxis, renderer);
        plot.setNoDataMessage("No data available");
        plot.setOutlineVisible(false);
        plot.setDomainGridlinesVisible(false);
        plot.setRangeGridlinesVisible(false);

        plot.getDomainAxis().setLowerMargin(0.0D);
        plot.getDomainAxis().setUpperMargin(0.0D);

        plot.setBackgroundPaint(Color.WHITE);
        chart = new JFreeChart(plot);
        chart.setPadding(new RectangleInsets(0.0, 0.0, 0.0, 5));
        chart.setBorderPaint(null);
        chart.setBackgroundPaint(null);
        chart.getLegend().setFrame(BlockBorder.NONE);

    }

    private void updateChartDataset(Map<Integer, Double> barChartData) {
        // column keys...    
        int counter = 0;
        // update the dataset...
        DefaultCategoryDataset dataset = (DefaultCategoryDataset) ((CategoryPlot) chart.getPlot()).getDataset();
        dataset.clear();
        for (double d : barChartData.values()) {
            dataset.addValue(Math.log(d) + 0.1, "protData", (counter++) + "");
        }
    }

    public abstract void setMainAppliedFilter(boolean mainAppliedFilter);

    public abstract void applyFilter(Set<Integer> columnIndexs);

}
